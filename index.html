<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Rompecabezas para Gaby</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            overflow-x: hidden;
            position: relative;
            width: 100%;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #f8f6f3 0%, #ebe8e3 100%);
            color: #3d3935;
            min-height: 100vh;
            padding: 40px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            overscroll-behavior: none;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 300;
            letter-spacing: 3px;
            margin-bottom: 8px;
            color: #8b7355;
        }

        .header p {
            font-size: 0.9rem;
            color: #9b8b7e;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .main-area {
            background: #ffffff;
            border: 1px solid #e0d5c7;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 8px 30px rgba(139, 115, 85, 0.08);
            margin-bottom: 25px;
        }

        .canvas-label {
            font-size: 0.75rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #a59885;
            margin-bottom: 18px;
            font-weight: 400;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 6px;
            background: #fdfcfb;
            cursor: grab;
            border: 1px solid #e0d5c7;
            box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.04);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #gameCanvas.dragging {
            cursor: grabbing;
        }

        .controls-section {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-box {
            background: #fdfcfb;
            border: 1px solid #e8e0d5;
            border-radius: 6px;
            padding: 18px;
            text-align: center;
        }

        .info-label {
            font-size: 0.7rem;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            color: #a59885;
            margin-bottom: 10px;
        }

        .info-value {
            font-size: 1.8rem;
            font-weight: 300;
            color: #8b7355;
        }

        .progress-section {
            background: #fdfcfb;
            border: 1px solid #e8e0d5;
            border-radius: 6px;
            padding: 18px;
        }

        .progress-label {
            font-size: 0.75rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f0ebe3;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #e0d5c7;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #b8a088 0%, #8b7355 100%);
            transition: width 0.4s ease;
            box-shadow: 0 0 8px rgba(139, 115, 85, 0.2);
        }

        .buttons-section {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        button {
            padding: 12px 24px;
            border: 1px solid #d5c8b8;
            background: #fdfcfb;
            color: #5d5349;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 400;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            min-height: 44px;
        }

        button:active {
            transform: translateY(1px);
        }

        button:hover {
            background: #f8f5f0;
            border-color: #b8a088;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 115, 85, 0.12);
        }

        button.primary {
            background: linear-gradient(135deg, #b8a088 0%, #8b7355 100%);
            color: #ffffff;
            border: none;
            font-weight: 500;
        }

        button.primary:hover {
            background: linear-gradient(135deg, #c8b098 0%, #9b8365 100%);
            box-shadow: 0 6px 16px rgba(139, 115, 85, 0.2);
        }

        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #ffffff;
            border: 1px solid #d5c8b8;
            border-radius: 12px;
            padding: 50px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(139, 115, 85, 0.15);
            animation: slideIn 0.4s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-40px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-content h2 {
            font-size: 1.8rem;
            font-weight: 300;
            letter-spacing: 2px;
            margin-bottom: 20px;
            color: #8b7355;
        }

        .modal-content p {
            font-size: 0.95rem;
            color: #7d6f62;
            margin: 15px 0;
        }

        @media (max-width: 900px) {
            body {
                padding: 20px 15px;
            }
            
            .header h1 {
                font-size: 1.4rem;
                letter-spacing: 2px;
            }
            
            .header p {
                font-size: 0.85rem;
            }
            
            .main-area {
                padding: 20px;
            }
            
            .controls-section {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
            
            .buttons-section {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            button {
                padding: 14px 20px;
                font-size: 0.9rem;
            }
        }
        
        @media (max-width: 600px) {
            body {
                padding: 15px 10px;
            }
            
            .header {
                margin-bottom: 20px;
            }
            
            .header h1 {
                font-size: 1.2rem;
                letter-spacing: 1px;
            }
            
            .header p {
                font-size: 0.8rem;
            }
            
            .main-area {
                padding: 15px;
                margin-bottom: 15px;
            }
            
            .canvas-label {
                font-size: 0.7rem;
                margin-bottom: 12px;
            }
            
            .info-box,
            .progress-section {
                padding: 12px;
            }
            
            .info-label {
                font-size: 0.65rem;
                margin-bottom: 8px;
            }
            
            .info-value {
                font-size: 1.5rem;
            }
            
            .progress-label {
                font-size: 0.7rem;
            }
            
            button {
                padding: 12px 16px;
                font-size: 0.85rem;
            }
            
            .modal-content {
                padding: 30px 25px;
                margin: 0 15px;
            }
            
            .modal-content h2 {
                font-size: 1.5rem;
            }
            
            .modal-content p {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Un rompecabezas especial para mi mona</h1>
            <p>Felices 9 meses</p>
        </div>

        <div class="main-area">
            <div class="canvas-label">Arma el puzzle</div>
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="controls-section">
            <div class="info-box">
                <div class="info-label">Piezas</div>
                <div class="info-value"><span id="placedCount">0</span>/36</div>
            </div>
            <div class="info-box">
                <div class="info-label">Completado</div>
                <div class="info-value" id="percentCount">0%</div>
            </div>
            <div class="progress-section" style="grid-column: 1/-1;">
                <div class="progress-label">Progreso</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar"></div>
                </div>
            </div>
        </div>

        <div class="buttons-section">
            <button class="primary" onclick="game.newGame()">Nuevo juego</button>
            <button onclick="game.reset()">Reiniciar</button>
            <button onclick="game.clearAll()">Borrar todo</button>
        </div>
    </div>

    <div class="modal" id="finishModal">
        <div class="modal-content">
            <h2>Â¡Completado! ðŸŽ‰</h2>
            <p>Has terminado el rompecabezas</p>
            <button class="primary" onclick="game.newGame()">Nuevo juego</button>
        </div>
    </div>

    <script>
        const CONFIG = {
            COLS: 6,
            ROWS: 6,
            CANVAS_W: 800,
            CANVAS_H: 800,
            SNAP_THRESHOLD: 28,
            get TOTAL() { return this.COLS * this.ROWS; }
        };

        class PuzzleGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.canvas.width = CONFIG.CANVAS_W;
                this.canvas.height = CONFIG.CANVAS_H;
                
                this.pieceW = CONFIG.CANVAS_W / CONFIG.COLS;
                this.pieceH = CONFIG.CANVAS_H / CONFIG.ROWS;
                
                this.pieces = [];
                this.placed = new Set();
                this.baseImg = null;
                
                this.dragPiece = null;
                this.offsetX = 0;
                this.offsetY = 0;
                this.rafId = null;
                
                this.init();
            }

            async init() {
                console.log("ðŸŽ® Iniciando...");
                
                // Limpiar estado antiguo si la configuraciÃ³n cambiÃ³
                const saved = localStorage.getItem('puzzleState');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        if (!state.pieces || state.pieces.length !== CONFIG.TOTAL) {
                            console.log("âš ï¸ ConfiguraciÃ³n cambiÃ³, limpiando estado...");
                            localStorage.removeItem('puzzleState');
                        }
                    } catch (e) {
                        localStorage.removeItem('puzzleState');
                    }
                }
                
                await this.createBaseImage();
                this.createPieces();
                this.setupEvents();
                this.loadState();
                this.draw();
                this.updateUI();
                
                console.log("âœ“ Listo");
            }

            async createBaseImage() {
                return new Promise(resolve => {
                    const canvas = document.createElement('canvas');
                    canvas.width = CONFIG.CANVAS_W;
                    canvas.height = CONFIG.CANVAS_H;
                    const ctx = canvas.getContext('2d');

                    // Fondo
                    const grad = ctx.createLinearGradient(0, 0, CONFIG.CANVAS_W, CONFIG.CANVAS_H);
                    grad.addColorStop(0, '#f5f1e8');
                    grad.addColorStop(0.5, '#ede7db');
                    grad.addColorStop(1, '#e5dfd3');
                    ctx.fillStyle = grad;
                    ctx.fillRect(0, 0, CONFIG.CANVAS_W, CONFIG.CANVAS_H);

                    // Formas geomÃ©tricas abstractas muy visibles para confundir
                    ctx.save();
                    ctx.globalAlpha = 0.2;
                    
                    // CÃ­rculos grandes
                    const circles = [
                        { x: 150, y: 200, r: 180, color: '#d4b896' },
                        { x: 650, y: 600, r: 220, color: '#c9a87e' },
                        { x: 400, y: 100, r: 140, color: '#b89f7f' },
                        { x: 600, y: 300, r: 160, color: '#d9c2a5' },
                        { x: 200, y: 650, r: 130, color: '#c2a589' }
                    ];
                    circles.forEach(c => {
                        ctx.fillStyle = c.color;
                        ctx.beginPath();
                        ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // LÃ­neas diagonales curvas
                    ctx.strokeStyle = '#9d8366';
                    ctx.lineWidth = 50;
                    for (let i = 0; i < 6; i++) {
                        ctx.beginPath();
                        ctx.moveTo(-100, 140 * i);
                        ctx.quadraticCurveTo(CONFIG.CANVAS_W / 2, 140 * i + 80, CONFIG.CANVAS_W + 100, 140 * i);
                        ctx.stroke();
                    }
                    
                    // Formas geomÃ©tricas
                    ctx.fillStyle = '#c5a582';
                    ctx.fillRect(50, 400, 220, 220);
                    ctx.fillRect(530, 40, 200, 200);
                    
                    // TriÃ¡ngulos
                    ctx.fillStyle = '#b89f7f';
                    ctx.beginPath();
                    ctx.moveTo(700, 100);
                    ctx.lineTo(750, 200);
                    ctx.lineTo(650, 200);
                    ctx.fill();
                    
                    ctx.restore();

                    // Puntos decorativos
                    ctx.fillStyle = 'rgba(180, 160, 140, 0.08)';
                    for (let i = 0; i < 80; i++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * CONFIG.CANVAS_W, Math.random() * CONFIG.CANVAS_H, 
                               Math.random() * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // PatrÃ³n de lÃ­neas sutiles
                    ctx.save();
                    ctx.globalAlpha = 0.03;
                    ctx.strokeStyle = '#b8a088';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < CONFIG.CANVAS_W; i += 30) {
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, CONFIG.CANVAS_H);
                        ctx.stroke();
                    }
                    for (let i = 0; i < CONFIG.CANVAS_H; i += 30) {
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(CONFIG.CANVAS_W, i);
                        ctx.stroke();
                    }
                    ctx.restore();

                    // Marco
                    ctx.strokeStyle = 'rgba(180, 160, 140, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(60, 80, CONFIG.CANVAS_W - 120, CONFIG.CANVAS_H - 160);

                    // Esquinas
                    ctx.strokeStyle = 'rgba(180, 160, 140, 0.15)';
                    const s = 25;
                    [[60, 80], [CONFIG.CANVAS_W - 60, 80], 
                     [60, CONFIG.CANVAS_H - 80], [CONFIG.CANVAS_W - 60, CONFIG.CANVAS_H - 80]].forEach(([x, y]) => {
                        ctx.beginPath();
                        ctx.moveTo(x, y + (y < CONFIG.CANVAS_H / 2 ? s : -s));
                        ctx.lineTo(x, y);
                        ctx.lineTo(x + (x < CONFIG.CANVAS_W / 2 ? s : -s), y);
                        ctx.stroke();
                    });

                    // Texto muy grande y rotado para mÃ¡xima dificultad
                    ctx.fillStyle = '#4a4035';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = '300 115px -apple-system, sans-serif';
                    
                    // Rotar todo el canvas ligeramente
                    ctx.save();
                    ctx.translate(CONFIG.CANVAS_W / 2, CONFIG.CANVAS_H / 2);
                    ctx.rotate(-0.08); // RotaciÃ³n sutil pero suficiente para confundir
                    
                    // Frase en 3 lÃ­neas
                    ctx.fillText('Â¿Crees que', 0, -200);
                    ctx.fillText('hay muchos', 0, 0);
                    ctx.fillText('chivos?', 0, 200);
                    
                    ctx.restore();

                    // LÃ­neas decorativas sutiles alrededor del texto
                    ctx.strokeStyle = 'rgba(180, 160, 140, 0.25)';
                    ctx.lineWidth = 1;
                    
                    // LÃ­nea arriba
                    ctx.beginPath();
                    ctx.moveTo(CONFIG.CANVAS_W / 2 - 250, 120);
                    ctx.lineTo(CONFIG.CANVAS_W / 2 + 250, 120);
                    ctx.stroke();
                    
                    // LÃ­nea abajo
                    ctx.beginPath();
                    ctx.moveTo(CONFIG.CANVAS_W / 2 - 200, 680);
                    ctx.lineTo(CONFIG.CANVAS_W / 2 + 200, 680);
                    ctx.stroke();

                    this.baseImg = canvas;
                    resolve();
                });
            }

            createPieces() {
                this.pieces = [];
                const margin = 30;
                
                for (let row = 0; row < CONFIG.ROWS; row++) {
                    for (let col = 0; col < CONFIG.COLS; col++) {
                        this.pieces.push({
                            id: row * CONFIG.COLS + col,
                            row, col,
                            targetX: col * this.pieceW,
                            targetY: row * this.pieceH,
                            x: margin + Math.random() * (CONFIG.CANVAS_W - this.pieceW - 2 * margin),
                            y: margin + Math.random() * (CONFIG.CANVAS_H - this.pieceH - 2 * margin),
                            placed: false,
                            z: 0
                        });
                    }
                }
            }

            setupEvents() {
                const getPos = (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const scaleX = this.canvas.width / rect.width;
                    const scaleY = this.canvas.height / rect.height;
                    
                    let clientX, clientY;
                    if (e.touches && e.touches.length > 0) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    } else if (e.changedTouches && e.changedTouches.length > 0) {
                        clientX = e.changedTouches[0].clientX;
                        clientY = e.changedTouches[0].clientY;
                    } else {
                        clientX = e.clientX;
                        clientY = e.clientY;
                    }
                    
                    return {
                        x: (clientX - rect.left) * scaleX,
                        y: (clientY - rect.top) * scaleY
                    };
                };

                const onDown = (e) => {
                    e.preventDefault();
                    const pos = getPos(e);
                    
                    // Buscar piezas no colocadas, ordenadas por z-index (del frente hacia atrÃ¡s)
                    const unplacedPieces = this.pieces
                        .filter(p => !p.placed)
                        .sort((a, b) => b.z - a.z);
                    
                    // Buscar la primera pieza (la del frente) que contiene el punto
                    for (const p of unplacedPieces) {
                        // Verificar si el click estÃ¡ dentro de la pieza con pequeÃ±o margen para mejor detecciÃ³n
                        if (pos.x >= p.x - 2 && pos.x <= p.x + this.pieceW + 2 &&
                            pos.y >= p.y - 2 && pos.y <= p.y + this.pieceH + 2) {
                            
                            this.dragPiece = p;
                            this.offsetX = pos.x - p.x;
                            this.offsetY = pos.y - p.y;
                            
                            // Traer al frente - asignar el z-index mÃ¡s alto
                            const maxZ = Math.max(0, ...this.pieces.map(piece => piece.z));
                            p.z = maxZ + 1;
                            
                            this.canvas.classList.add('dragging');
                            this.draw();
                            break;
                        }
                    }
                };

                const onMove = (e) => {
                    if (!this.dragPiece) return;
                    e.preventDefault();
                    
                    const pos = getPos(e);
                    
                    this.dragPiece.x = pos.x - this.offsetX;
                    this.dragPiece.y = pos.y - this.offsetY;
                    
                    // LÃ­mites con bounds checking seguro
                    this.dragPiece.x = Math.max(0, Math.min(CONFIG.CANVAS_W - this.pieceW, this.dragPiece.x));
                    this.dragPiece.y = Math.max(0, Math.min(CONFIG.CANVAS_H - this.pieceH, this.dragPiece.y));
                    
                    // Usar requestAnimationFrame para smooth rendering
                    if (!this.rafId) {
                        this.rafId = requestAnimationFrame(() => {
                            this.draw();
                            this.rafId = null;
                        });
                    }
                };

                const onUp = (e) => {
                    if (!this.dragPiece) return;
                    e.preventDefault();
                    
                    const p = this.dragPiece;
                    
                    // Verificar snap (centro de pieza para mejor precisiÃ³n)
                    const centerX = p.x + this.pieceW / 2;
                    const centerY = p.y + this.pieceH / 2;
                    const targetCenterX = p.targetX + this.pieceW / 2;
                    const targetCenterY = p.targetY + this.pieceH / 2;
                    
                    const dist = Math.sqrt(
                        Math.pow(centerX - targetCenterX, 2) + 
                        Math.pow(centerY - targetCenterY, 2)
                    );
                    
                    if (dist < CONFIG.SNAP_THRESHOLD) {
                        p.x = p.targetX;
                        p.y = p.targetY;
                        p.placed = true;
                        this.placed.add(p.id);
                        
                        // Feedback hÃ¡ptico en mÃ³viles
                        if (navigator.vibrate) {
                            navigator.vibrate(10);
                        }
                        
                        console.log(`âœ“ Pieza ${p.id + 1}/${CONFIG.TOTAL}`);
                        
                        if (this.placed.size === CONFIG.TOTAL) {
                            setTimeout(() => this.finish(), 300);
                        }
                    }
                    
                    this.dragPiece = null;
                    this.canvas.classList.remove('dragging');
                    this.saveState();
                    this.draw();
                    this.updateUI();
                };

                this.canvas.addEventListener('mousedown', onDown);
                this.canvas.addEventListener('touchstart', onDown, { passive: false });
                
                window.addEventListener('mousemove', onMove);
                window.addEventListener('touchmove', onMove, { passive: false });
                
                window.addEventListener('mouseup', onUp);
                window.addEventListener('touchend', onUp, { passive: false });
            }

            draw() {
                // Limpiar
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, CONFIG.CANVAS_W, CONFIG.CANVAS_H);

                // Grid muy sutil
                this.ctx.strokeStyle = 'rgba(139, 115, 85, 0.04)';
                this.ctx.lineWidth = 0.5;
                for (let i = 1; i < CONFIG.COLS; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * this.pieceW, 0);
                    this.ctx.lineTo(i * this.pieceW, CONFIG.CANVAS_H);
                    this.ctx.stroke();
                }
                for (let i = 1; i < CONFIG.ROWS; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i * this.pieceH);
                    this.ctx.lineTo(CONFIG.CANVAS_W, i * this.pieceH);
                    this.ctx.stroke();
                }

                // Highlight colocadas (muy sutil)
                this.ctx.fillStyle = 'rgba(139, 115, 85, 0.04)';
                for (const id of this.placed) {
                    const p = this.pieces.find(p => p.id === id);
                    if (p) this.ctx.fillRect(p.targetX, p.targetY, this.pieceW, this.pieceH);
                }

                // Dibujar piezas (por z-index)
                const sorted = [...this.pieces].sort((a, b) => a.z - b.z);
                
                for (const p of sorted) {
                    // Imagen
                    this.ctx.drawImage(
                        this.baseImg,
                        p.targetX, p.targetY, this.pieceW, this.pieceH,
                        p.x, p.y, this.pieceW, this.pieceH
                    );
                    
                    // Borde
                    if (p === this.dragPiece) {
                        // Arrastrada
                        this.ctx.strokeStyle = '#b8a088';
                        this.ctx.lineWidth = 2;
                        this.ctx.shadowColor = 'rgba(139, 115, 85, 0.4)';
                        this.ctx.shadowBlur = 10;
                        this.ctx.strokeRect(p.x, p.y, this.pieceW, this.pieceH);
                        this.ctx.shadowBlur = 0;
                        
                        // Preview
                        const centerX = p.x + this.pieceW / 2;
                        const centerY = p.y + this.pieceH / 2;
                        const targetCenterX = p.targetX + this.pieceW / 2;
                        const targetCenterY = p.targetY + this.pieceH / 2;
                        const dist = Math.sqrt(
                            Math.pow(centerX - targetCenterX, 2) + 
                            Math.pow(centerY - targetCenterY, 2)
                        );
                        
                        if (dist < CONFIG.SNAP_THRESHOLD) {
                            this.ctx.fillStyle = 'rgba(139, 115, 85, 0.08)';
                            this.ctx.fillRect(p.targetX, p.targetY, this.pieceW, this.pieceH);
                            this.ctx.strokeStyle = 'rgba(139, 115, 85, 0.25)';
                            this.ctx.lineWidth = 1.5;
                            this.ctx.strokeRect(p.targetX, p.targetY, this.pieceW, this.pieceH);
                        }
                    } else if (p.placed) {
                        this.ctx.strokeStyle = 'rgba(139, 115, 85, 0.35)';
                        this.ctx.lineWidth = 1.5;
                        this.ctx.strokeRect(p.x, p.y, this.pieceW, this.pieceH);
                    } else {
                        this.ctx.strokeStyle = 'rgba(139, 115, 85, 0.2)';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(p.x, p.y, this.pieceW, this.pieceH);
                    }
                }
            }

            updateUI() {
                const placed = this.placed.size;
                const pct = Math.round((placed / CONFIG.TOTAL) * 100);
                document.getElementById('placedCount').textContent = placed;
                document.getElementById('percentCount').textContent = pct + '%';
                document.getElementById('progressBar').style.width = pct + '%';
            }

            finish() {
                document.getElementById('finishModal').classList.add('show');
                localStorage.removeItem('puzzleState');
            }

            newGame() {
                document.getElementById('finishModal').classList.remove('show');
                localStorage.removeItem('puzzleState');
                location.reload();
            }

            reset() {
                const margin = 30;
                for (const p of this.pieces) {
                    if (p.placed) {
                        p.placed = false;
                        p.x = margin + Math.random() * (CONFIG.CANVAS_W - this.pieceW - 2 * margin);
                        p.y = margin + Math.random() * (CONFIG.CANVAS_H - this.pieceH - 2 * margin);
                    }
                }
                this.placed.clear();
                this.saveState();
                this.draw();
                this.updateUI();
            }

            clearAll() {
                const margin = 30;
                for (const p of this.pieces) {
                    p.placed = false;
                    p.x = margin + Math.random() * (CONFIG.CANVAS_W - this.pieceW - 2 * margin);
                    p.y = margin + Math.random() * (CONFIG.CANVAS_H - this.pieceH - 2 * margin);
                }
                this.placed.clear();
                localStorage.removeItem('puzzleState');
                this.draw();
                this.updateUI();
            }

            saveState() {
                const state = {
                    pieces: this.pieces.map(p => ({ id: p.id, x: p.x, y: p.y, placed: p.placed, z: p.z })),
                    placed: Array.from(this.placed)
                };
                localStorage.setItem('puzzleState', JSON.stringify(state));
            }

            loadState() {
                const saved = localStorage.getItem('puzzleState');
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        // Validar que el estado corresponde al nÃºmero correcto de piezas
                        if (state.pieces && state.pieces.length === CONFIG.TOTAL) {
                            for (const sp of state.pieces) {
                                const p = this.pieces.find(p => p.id === sp.id);
                                if (p) {
                                    p.x = sp.x;
                                    p.y = sp.y;
                                    p.placed = sp.placed || false;
                                    p.z = sp.z || 0;
                                }
                            }
                            this.placed = new Set(state.placed || []);
                            console.log(`âœ“ Restaurado: ${this.placed.size} piezas`);
                        } else {
                            console.log("âš ï¸ Estado incompatible, empezando de nuevo");
                        }
                    } catch (e) {
                        console.error('Error al cargar:', e);
                    }
                }
            }
        }

        let game;
        window.addEventListener('load', () => {
            game = new PuzzleGame();
        });

        window.addEventListener('beforeunload', () => {
            if (game && game.placed.size > 0) {
                game.saveState();
            }
        });
    </script>
</body>
</html>
